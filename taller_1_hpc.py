# -*- coding: utf-8 -*-
"""Taller 1 HPC

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SZnjz4k7DsD2gjYnl262DrELZl16mq8b
"""

import itertools
import math
import time

def distancia(ciudad1, ciudad2):
    return math.sqrt((ciudad1[0] - ciudad2[0])**2 + (ciudad1[1] - ciudad2[1])**2)

def distancia_total(ruta, ciudades):
    total = 0
    for i in range(len(ruta) - 1):
        total += distancia(ciudades[ruta[i]], ciudades[ruta[i + 1]])
    total += distancia(ciudades[ruta[-1]], ciudades[ruta[0]])  # retorno al origen
    return total

def tsp_secuencial(ciudades):
    n = len(ciudades)
    mejor_ruta = None
    menor_distancia = float("inf")
    for ruta in itertools.permutations(range(n)):
        d = distancia_total(ruta, ciudades)
        if d < menor_distancia:
            menor_distancia = d
            mejor_ruta = ruta
    return mejor_ruta, menor_distancia

# Ejemplo de prueba
if __name__ == "__main__":
    ciudades = [(0,0), (1,5), (5,2), (6,6), (2,3), (4,2), (9,1), (4,1), (7,2), (3,5)]
    inicio = time.time()
    ruta, dist = tsp_secuencial(ciudades)
    fin = time.time()
    print("Ruta óptima:", ruta)
    print("Distancia mínima:", dist)
    print("Tiempo (s):", fin - inicio)

import itertools
import math
import time
from multiprocessing import Pool, cpu_count

def distancia(ciudad1, ciudad2):
    return math.sqrt((ciudad1[0] - ciudad2[0])**2 + (ciudad1[1] - ciudad2[1])**2)

def distancia_total(ruta, ciudades):
    total = 0
    for i in range(len(ruta) - 1):
        total += distancia(ciudades[ruta[i]], ciudades[ruta[i + 1]])
    total += distancia(ciudades[ruta[-1]], ciudades[ruta[0]])
    return total

def evaluar_ruta(ruta_ciudades):
    ruta, ciudades = ruta_ciudades
    return distancia_total(ruta, ciudades), ruta

def tsp_paralelo(ciudades):
    rutas = list(itertools.permutations(range(len(ciudades))))
    with Pool(cpu_count()) as p:
        resultados = p.map(evaluar_ruta, [(ruta, ciudades) for ruta in rutas])
    mejor = min(resultados, key=lambda x: x[0])
    return mejor[1], mejor[0]

if __name__ == "__main__":
    ciudades = [(0,0), (1,5), (5,2), (6,6), (2,3), (4,2), (9,1), (4,1), (7,2), (3,5)]
    inicio = time.time()
    ruta, dist = tsp_paralelo(ciudades)
    fin = time.time()
    print("Ruta óptima:", ruta)
    print("Distancia mínima:", dist)
    print("Tiempo (s):", fin - inicio)